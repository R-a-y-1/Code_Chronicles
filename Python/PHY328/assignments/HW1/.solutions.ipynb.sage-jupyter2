{"attachments":{},"cell_type":"markdown","id":"6c5d3f","input":"<span style='font-size:xx-large'>**Q1**</span>  \n\n<span style='font-size:small'>In python arrays data is transposed such that a matrix with </span><span style='font-size:small'>_A_</span><span style='font-size:small'>  columns by </span><span style='font-size:small'>_B_</span><span style='font-size:small'> rows becomes a 2D array with </span><span style='font-size:small'>_B_</span><span style='font-size:small'> columns and </span><span style='font-size:small'>_A_</span><span style='font-size:small'> rows. We now have a </span><span style='font-size:small'>_N_</span><span style='font-size:small'> by 2 ray matrix being transformed by a \\(2,2\\) matrix which allows the multiplication to be processed.</span>\n$$\\left( \\begin{matrix} a & b \\\\ c & d \\end{matrix} \\right) \\left( \\begin{matrix} y_1 & y_2 & ... \\\\ \\theta_1 & \\theta_2 & ... \\end{matrix} \\right)  = \\\\ \\left( \\begin{matrix} ay_1+b\\theta_1 & ay_2+b\\theta_2 & ... \\\\ cy_1+d\\theta_1 &  cy_2+d\\theta_2 & ... \\end{matrix} \\right)$$  \nAs can be seen, when this array is transformed by matrix M, the output array countains the propagattion of the incoming ray.  \n\n","pos":0,"type":"cell"}
{"attachments":{},"cell_type":"markdown","id":"ee7f5e","input":"<span style='font-size:xx-large'>**Q2**</span>\n\nwe have 4 different use cases that broadly do the same thing. In terms of clarity it would make sense to create a new class for each element that inherit a method from a main bigger class.\n\nPlan:\n\n- Have one big class that would contain the array of incoming rays since I assume those would always be the same\n- This can also include the transformation function\n- Create 4 separate sub\\-classes for each unique optical element\n- Within each unique sub\\-class include the relevant transformation matrix\n\nBelow is a rudimentary plan for the code:\\-\n\n```\nclass Main:                             #Creating the main class to hold all of the subclasses\n\t\n    rays = [the ray data]                 # Currently unsure as to whether I should allow the pass-through of the ray data or not\n    \n\tdef propagate(self, rays):\n        '''\n        This is the propagation function that will compute the matrix multiplication of the rays and transformation matrix.\n        \n        Inputs\n        -------\n        \n        self: 2D Matrix\n        \tThe specific transformation associated with the optical element\n         \n        rays: 2 x N Matrix\n        \tThe incoming rays\n            \n        Returns\n        --------\n        \n        propagated_wave: 2 x N Matrix\n        \tThe computed transformed rays at the incidence boundary\n        '''\n        return propagated_wave\n    \n    class OpticalElement1:\n        transformation matrix = [matrix]\n        propagated_wave = propagate(transformation_matrix, rays)\n        \n    class OpticalElement2:\n        transformation matrix = [matrix]\n        propagated_wave = propagate(transformation_matrix, rays)\n```\n\nAnd now my final version:\\-\n\n```\nimport numpy as np\n\nclass Optical:\n    rays = [[0,0,0,0],[0,0,0,0]]\n\n    def propagate(self):\n        '''\n        This is the propagation function that will compute the matrix multiplication of the rays and transformation matrix. There is no need to input any variables when calling this function.\n\n        Inputs\n        -------\n\n        None\n\n        Returns\n        --------\n\n        propagated_wave: 2 x N Matrix\n        \tThe computed transformed rays at the incidence boundary\n        '''\n        #Since there is no **user** input for this function I do not see the need for tests for this function\n        propagated_wave = np.matmul(self.matrix, Optical.rays) # Matrix multiplication function\n\n        return propagated_wave\n\nclass Transmission(Optical): # This will be the free transmission class where the user must define the matrix themself\n    def __init__(self, d):            # I will be using the __init__ function that runs when an object is added to test user input\n        '''\n        Initialising function. Runs some tests on the user input and\n        formats the matrix so that it is in the correct shape for the\n        multiplication function.\n\n        Input\n        -------\n\n        d: int, float\n            The transmission deflection parameter\n\n        Returns\n        --------\n\n        None\n        '''\n        try:\n            assert(type(d) == int or float) # This checks that the input is a number\n        except AssertionError:\n            return print('Input must be a number')\n        self.matrix = [[1, d],[0, 1]]\n        return\n\nclass Planar(Optical): # This will be the free transmission class where the user must define the matrix themself\n    def __init__(self, n):            # I will be using the __init__ function that runs when an object is added to test user input\n        '''\n        Initialising function. Runs some tests on the user input and\n        formats the matrix so that it is in the correct shape for the\n        multiplication function.\n\n        Input\n        -------\n\n        n: int, float\n            The refractive index ratio between the two planes\n\n        Returns\n        --------\n\n        None\n        '''\n        try:\n            assert(type(n) == int or float) # This checks that the input is a number\n        except AssertionError:\n            return print('Input must be a number')\n        self.matrix = [[1, 0],[0, n]]\n        return\n\nclass ThinLens(Optical):\n    def __init__(self, f):\n        '''\n        Initialising function. Runs some tests on the user input and\n        formats the matrix so that it is in the correct shape for the\n        multiplication function.\n\n        Input\n        -------\n\n        f: int, float\n            The focal distance of the lens in meters\n\n        Returns\n        --------\n\n        None\n        '''\n        try:\n            assert(type(f) == int or float) # This checks that the input is a number\n        except AssertionError:\n            return print('Input must be a number')\n        self.matrix = [[1, 0],[1/f, 1]]\n        return\n\nclass Spherical(Optical):\n    def __init__(self, n1, n2, R):\n        '''\n        Initialising function. Runs some tests on the user input and\n        formats the matrix so that it is in the correct shape for the\n        multiplication function.\n\n        Input\n        -------\n\n        n1: int float\n            The refractive index of the incident ray material\n\n        n2: int float\n            The refractive index of the refracted ray material\n\n        R: int float\n            The radius of curvature of the lens. R > 0 for convex lens\n\n        Returns\n        --------\n\n        None\n        '''\n        for variable in [n1,n2,R]:\n            try:\n                assert(type(variable) == int or float) # This checks that the input is a number\n            except AssertionError:\n                return print('Input must be a number')\n        self.matrix = [[1, 0],[(n1-n2)/R*n2, n1/n2]]\n        return\n```\n\n","pos":1,"type":"cell"}
{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-da521e01-9713-4dce-b8ed-2e6faff5039e.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"last_ipynb_save":1714131203143,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":true,"type":"settings"}
{"cell_type":"code","end":1711380105459,"exec_count":6,"id":"e4c187","input":"Lens = ThickLens(1.4701, 0.25, -0.25, 0.01)\nprint(Lens.focus)","kernel":"python3","output":{"0":{"name":"stdout","text":"0.2676123826792812\n"}},"pos":11.8125,"start":1711380105456,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"5ec5b4","input":"<div style='text-align: center;'><span style='font-size:xx-large;' class='bold'><em>Executable final block</em></span></div>\n\n","pos":11.5,"type":"cell"}
{"cell_type":"markdown","id":"934323","input":"<div style='text-align: center;'><span style='font-size:xx-large' class='bold'> The Graph:</span></div>","pos":11.875,"type":"cell"}
{"cell_type":"markdown","id":"ac23ab","input":"<span style='font-size:xx-large'>**Q5**</span>\n\n<span style='font-size:small'>This is a simple task. All I need to do is create new objects for each new wavelength as the refractive index will be different. After </span>  \n<span style='font-size:small'>that I create a polar plot using matplotlib with the image as a background.</span>\n\n```py\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nrng = np.random.default_rng(seed=50)\nrints = rng.integers(low=0, high=100, size=50)\n\nr = 0.250\nd = 0.010\n\nwave_400 = ThickLens(1.4701, r, r, d)\nwave_410 = ThickLens(1.520, r, r, d)\n\nOptical.rays = [rints,rints]\nwave_400.propagate()\nwave_410.propagate()\n\ny_400 = wave_400.propagated_wave[0,:]\nangle_400 = wave_400.propagated_wave[1,:]\n\ny_410 = wave_410.propagated_wave[0,:]\nangle_410 = wave_410.propagated_wave[1,:]\n\n\nfig, ax = plt.subplots(subplot_kw = {'projection' : 'polar'})\nax.set_theta_direction(direction=1)\n\nax.plot(angle_400, y_400, 'ob')\nax.plot(angle_410, y_410, 'or')\n\nax.set_title('Angles')\nplt.show()\n```\n\n","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"c56461","input":"<span style='font-size:xx-large'>**Q4** </span>\n\nThis problem is most easily solved by adding a new class for a thick lens. This thick lens class will use some of the functions defined previously such as the `__add__()` to properly initialise itself. This allows me to hard code in the focal length without having to do complicated mathematics to determined if the optical element even converges.\n\nLooking up the specific details , there is a well known equation for the focal distance of a converging thick lens in air: \n\n<div style='text-align: center;'><span style='font-size:large'> $P =\\frac{1}{f}=(n-1)(\\frac{1}{R_1}-\\frac{1}{R_2}+\\frac{(n-1)d}{nR_1R_2})$ </span></div>\n\nA small plan for how my code should work:-\n\n```py\n 'I\\'ll create a new ThickLens class to hard code in the focal length'\nclass ThickLens(Optical):\n    def __init__(self, n, r1, r2, d):\n        '''\n        Tests seem a little unnecessary since I'm calling more basic classes that already test user input\n        '''\n        len1 = Spherical(1,n,r1)\n        len2 = Transmission(d)\n        len3 = Spherical(n,1,r2)\n        self.matrix = (len1 + len2 + len3).matrix\n        # This class should have a specific attribute for focal length\n        self.focus = ((n-1)((1/r1)-(1/r2)+(n-1)*d/n*r1*r2))**-1\n```\n\nMy solution:\\-  \n\n\n```py\nclass ThickLens(Optical):\n    def __init__(self, n, r1, r2, d):\n        '''\n        Tests seem a little unnecessary since I'm calling more basic classes that already test user input\n        '''\n        len1 = Spherical(1,n,r1)\n        len2 = Transmission(d)\n        len3 = Spherical(n,1,r2)\n        self.matrix = (len1 + len2 + len3).matrix\n        # This class should have a specific attribute for focal length\n        premult = n-1\n        radiidiff = (1/r1)-(1/r2)\n        travel = d*(n-1)/(n*r1*r2)\n        power = premult*(radiidiff + travel)\n        self.focus = power**-1\n        pass\n```\n\n","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"dcd0ca","input":"<span style='font-size:xx-large'>**An executable block incorporating all of my code together can be found at the final cell**</span>  \n\n","pos":-1,"type":"cell"}
{"cell_type":"markdown","id":"fce815","input":"<span style='font-size:xx-large'>**Q3**</span>  \n\n<span style='font-size:small'>I will implement the </span>`__add__`<span style='font-size:small'>method to allow the building of complex objects by adding them. What should actually happen though is that the refraction matrices should be multiplied, with the first item being the furthest right. The main issue to solve here being if the user needs to add multiple elements, and making sure that all the elements are consistent.</span>\n\n<span style='font-size:small'>My solution is as follows:\\-</span>\n\n```\nclass Optical:\n\n    def __add__(self, others):\n        '''\n        The function to build more complex optical systems by combining simpler optical objects. Complex object is built layer by layer from point of view of light path.\n\n        Inputs\n        -------\n\n        x1: Optical Object\n            e.g. ThinLens(1) or Spherical(3,4,5)\n\n        x2: Optical Object ArrayLike\n            One or multiple other optical class objects\n\n        e.g. Lens = Spherical(1,2,3) + Transmission(2) + Spherical(1,2,-3)\n\n        Outputs\n        --------\n\n        Output: Complex optical object\n            Initialises the Complex class for your object. The resultant matrix can be found under self.matrix\n        '''\n        try:\n            assert(type(others).__bases__ == type(self).__bases__) # Checking to see if the parent class of all items is also optical\n        except AssertionError:\n            return print(f'{others} must also be an optical object')\n        result = np.matmul(others.matrix, self.matrix)\n        output = Complex(result) # Making the result an optical object such that this code can be used to add multiple things together and stay self-consistent\n        return output\n\nclass Complex(Optical): # Created a new complex class to allow the building of any possible transformation matrix\n    def __init__(self, matrix):\n        '''\n        A class allowing for the creation of any custom transformation matrix. It is more advised to build this using a combination of smaller classes using the add function.\n\n        Input\n        ------\n\n        Matrix: ArrayLike\n            The 2 x 2 transformation matrix of the material\n\n        Output\n        -------\n\n        None\n        '''\n        try:\n            assert(np.shape(matrix) == (2,2))              # First we must check that the matrix is the correct shape\n        except AssertionError:\n            return print(f'Matrix is not in the correct shape')\n        for item in matrix:\n            try:                                          # Next we must check that all values are integers or floats\n                assert(type(item) == float or int)\n            except AssertionError:\n                return print(f'All matrix values must be integers or floats')\n        self.matrix = matrix\n        return\n       \n```\n\n","pos":4,"type":"cell"}
{"end":1710432869586,"exec_count":9,"id":"787f0d","input":"import matplotlib.pyplot as plt\nimport numpy as np\n\nsize = 5 #Deciding how many light rays to simulate\nrng = np.random.default_rng(seed=50) # Setting up my random number generator such that it is repeatable\nrints = rng.integers(low=0, high=90, size=size) # Making my random numbers, making sure they're integers with a max of 90. Light rays with angles at or greater than 90 do not hit the lens\nints = np.linspace(0, 40, num=size) # separating the light rays in height\n\nr = 0.250 # Lens curvature\nd = 0.010 # Lens thickness\n\nwave_400 = ThickLens(1.4701, r, r, d) # Making my lenses\nwave_410 = ThickLens(1.4691, r, r, d) # ^^\n\nOptical.rays = [np.zeros(size),rints] # Defining my light rays\nwave_400.propagate() # Propagating my waves\nwave_410.propagate()\n\ny_400 = wave_400.propagated_wave[0,:] # Pulling out my propagated wave heights and angles for 400 nm\nangle_400 = wave_400.propagated_wave[1,:]\n\ny_410 = wave_410.propagated_wave[0,:] # Repeat for 410 nm\nangle_410 = wave_410.propagated_wave[1,:]\n\nangle_400_rad = angle_400*(np.pi/180) # Converting my angles to radians for my plot\nangle_410_rad = angle_410*(np.pi/180)\n\nfig, ax = plt.subplots(subplot_kw = {'projection' : 'polar'})  # Making my polar plot\nax.set_theta_direction(direction=1)\n\nax.plot(angle_400_rad, ints/10, 'ob') # Plotting my data\nax.plot(angle_410_rad, ints/10, 'or')\n\n\nax.set_title('Refraction Positions and Angles of 400nm and 410nm')\nplt.show()\n\n\nprint(f'Height \\t   θ₄₀₀ \\t   θ₄₁₀ \\t Δθ (deg)')\nfor i in range(len(ints)):\n    print(f'{ints[i]} \\t {angle_400[i]: .7f} \\t {angle_410[i]: .7f} \\t {angle_400[i]-angle_410[i]: .3E}')\n\nprint(f'Lower frequency is refracting more??')","kernel":"python3","output":{"0":{"data":{"image/png":"f2fb45968be2b97a290d17c87fbaa9b10d34e1bf","text/plain":"<Figure size 864x504 with 1 Axes>"},"metadata":{"image/png":{"height":447,"width":440},"needs_background":"light"}},"1":{"name":"stdout","text":"Height \t   θ₄₀₀ \t   θ₄₁₀ \t Δθ (deg)\n0.0 \t  70.8953677 \t  70.8940712 \t  1.296E-03\n10.0 \t  70.8953677 \t  70.8940712 \t  1.296E-03\n20.0 \t  64.8186219 \t  64.8174365 \t  1.185E-03\n30.0 \t  75.9593225 \t  75.9579334 \t  1.389E-03\n40.0 \t  74.9465315 \t  74.9451610 \t  1.371E-03\nLower frequency is refracting more??\n"}},"pos":12,"start":1710432868773,"state":"done","type":"cell"}
{"end":1711379967368,"exec_count":3,"id":"2749d9","input":"import numpy as np\n\nclass Optical:\n    rays = np.array([[8,0,-8],[0,0,0]])\n\n    def __add__(self, others):\n        '''\n        The function to build more complex optical systems by combining simpler optical objects. Complex object is built layer by layer from point of view of light path.\n\n        Inputs\n        -------\n\n        x1: Optical Object\n            e.g. ThinLens(1) or Spherical(3,4,5)\n\n        x2: Optical Object ArrayLike\n            One or multiple other optical class objects\n\n        e.g. Lens = Spherical(1,2,3) + Transmission(2) + Spherical(1,2,-3)\n\n        Outputs\n        --------\n\n        Output: Complex optical object\n            Initialises the Complex class for your object. The resultant matrix can be found under self.matrix\n        '''\n        try:\n            assert(type(others).__bases__ == type(self).__bases__) # Checking to see if the parent class of all items is also optical\n        except AssertionError:\n            return print(f'BUILD ERROR: \\\"{others}\\\" must also be an optical object')\n        result = np.matmul(others.matrix, self.matrix)\n        output = Complex(result) # Making the result an optical object such that this code can be used to add multiple things together and stay self-consistent\n        return output\n\n    def propagate(self):\n        '''\n        This is the propagation function that will compute the matrix multiplication of the rays and transformation matrix. There is no need to input any variables when calling this function.\n\n        Inputs\n        -------\n\n        None\n\n        Returns\n        --------\n\n        propagated_wave: 2 x N Matrix\n        \tThe computed transformed rays at the incidence boundary\n        '''\n        #Since there is no **user** input for this function I do not see the need for tests for this function\n        self.propagated_wave = np.matmul(self.matrix, Optical.rays) # Matrix multiplication function\n\n        return self.propagated_wave\n\nclass Transmission(Optical): # This will be the free transmission class where the user must define the matrix themself\n    def __init__(self, d):            # I will be using the __init__ function that runs when an object is added to test user input\n        '''\n        Transmission through a material with a constant refractive index\n\n        Input\n        -------\n\n        d: int|float\n            The transmission distance\n\n        Returns\n        --------\n\n        None\n        '''\n        try:\n            assert(type(d) == int or float) # This checks that the input is a number\n        except AssertionError:\n            return print('Input must be a number')\n        self.matrix = [[1, d],[0, 1]]\n        return\n\nclass Planar(Optical): # This will be the free transmission class where the user must define the matrix themself\n    def __init__(self, n):            # I will be using the __init__ function that runs when an object is added to test user input\n        '''\n        A planar refracting surface\n\n        Input\n        -------\n\n        n: int|float\n            The refractive index ratio between the two materials\n\n        Returns\n        --------\n\n        None\n        '''\n        try:\n            assert(type(n) == int or float) # This checks that the input is a number\n        except AssertionError:\n            return print('Input must be a number')\n        self.matrix = [[1, 0],[0, n]]\n        return\n\nclass ThinLens(Optical):\n    def __init__(self, f):\n        '''\n        A lens modelled to have zero thickness\n\n        Input\n        -------\n\n        f: int, float\n            The focal distance of the lens in meters\n\n        Returns\n        --------\n\n        None\n        '''\n        try:\n            assert(type(f) == int or float) # This checks that the input is a number\n        except AssertionError:\n            return print('Input must be a number')\n        self.matrix = [[1, 0],[-1/f, 1]]\n        return\n\nclass Spherical(Optical):\n    def __init__(self, n1, n2, R):\n        '''\n        A spherical refracting surface\n\n        Input\n        -------\n\n        n1: int|float\n            The refractive index of the incident ray material\n\n        n2: int|float\n            The refractive index of the refracted ray material\n\n        R: int|float\n            The radius of curvature of the lens. R > 0 for convex lens\n\n        Returns\n        --------\n\n        None\n        '''\n        for variable in [n1,n2,R]:\n            try:\n                assert(type(variable) == int or float) # This checks that the input is a number\n            except AssertionError:\n                return print('Input must be a number')\n        self.matrix = [[1, 0],[(n1-n2)/R*n2, n1/n2]]\n        return\n\nclass Complex(Optical): # Created a new complex class to allow the building of any possible transformation matrix\n    def __init__(self, matrix):\n        '''\n        A class allowing for the creation of any custom transformation matrix. It is advised to build this using a combination of smaller classes using the add function.\n\n        Input\n        ------\n\n        Matrix: ArrayLike\n            The 2 x 2 transformation matrix of the material\n\n        Output\n        -------\n\n        None\n        '''\n        try:\n            assert(np.shape(matrix) == (2,2))              # First we must check that the matrix is the correct shape\n        except AssertionError:\n            return f'Matrix is not in the correct shape, must be [[a, b], [c, d]]'\n        for item in matrix:\n            for value in item:\n                try:                                          # Next we must check that all values are integers or floats\n                    assert(type(item) == float or int)\n                except AssertionError:\n                    return f'All matrix values must be integers or floats'\n        self.matrix = matrix\n        return\n\nclass ThickLens(Optical):\n    def __init__(self, n, r1, r2, d):\n        '''\n        Tests seem a little unnecessary since I'm calling more basic classes that already test user input\n        '''\n        len1 = Spherical(1,n,r1)\n        len2 = Transmission(d)\n        len3 = Spherical(n,1,r2)\n        self.matrix = (len1 + len2 + len3).matrix\n        # This class should have a specific attribute for focal length\n        premult = n-1\n        radiidiff = (1/r1)-(1/r2)\n        travel = d*(n-1)/(n*r1*r2)\n        power = premult*(radiidiff + travel)\n        self.focus = power**-1\n        pass","kernel":"python3","pos":11.75,"start":1711379967364,"state":"done","type":"cell"}
{"id":0,"time":1713883270248,"type":"user"}
{"last_load":1707778867513,"type":"file"}